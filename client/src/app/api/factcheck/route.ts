import { NextResponse } from "next/server";

type RequestBody = {
  query?: string;
};

export async function POST(req: Request) {
  try {
    /* ---------- 1. Parse input ---------- */
    const body: RequestBody = await req.json();
    const query = body.query?.trim();

    if (!query) {
      return NextResponse.json({ error: "Missing query" }, { status: 400 });
    }

    /* ---------- 2. API Key ---------- */
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      return NextResponse.json({
        result: {
          verdict: "unverified",
          confidence: 0,
          reasoning: "OpenAI API key not configured.",
          sources: []
        }
      });
    }

    /* ---------- 3. USER PROMPT (NO TIME LOGIC HERE) ---------- */
    const prompt = `
Evaluate the following claim using reliable, widely reported public information.

Rules:
- Return "true" if the claim is supported by credible public sources.
- Return "false" if the claim is factually incorrect.
- Return "mixed" if the claim is partially correct or vague.
- Return "unverified" if there is insufficient reliable information.

Return ONLY valid JSON:

{
  "verdict": "true | false | mixed | unverified",
  "confidence": number (0-100),
  "reasoning": string,
  "sources": string[]
}

Claim:
"${query.replace(/"/g, '\\"')}"
`;

    /* ---------- 4. OPENAI CALL (TIME FIX HERE âœ…) ---------- */
    const res = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "gpt-4o-mini",
        temperature: 0.2,
        messages: [
          {
            role: "system",
            content: `
You are a professional fact-checking assistant.

Assume the current date is AFTER the conclusion of the 2024 Indian general election.

Evaluate claims based on publicly available information
as it exists after the election has concluded.
`
          },
          {
            role: "user",
            content: prompt
          }
        ]
      })
    });

    if (!res.ok) {
      const err = await res.text();
      return NextResponse.json({
        result: {
          verdict: "unverified",
          confidence: 0,
          reasoning: "AI service error.",
          sources: [err]
        }
      });
    }

    const data = await res.json();
    const text = data?.choices?.[0]?.message?.content;

    if (!text) {
      return NextResponse.json({
        result: {
          verdict: "unverified",
          confidence: 20,
          reasoning: "No response generated by AI model.",
          sources: []
        }
      });
    }

    /* ---------- 5. SAFE JSON PARSE ---------- */
    try {
      const parsed = JSON.parse(text);
      const allowed = ["true", "false", "mixed", "unverified"];

      return NextResponse.json({
        result: {
          verdict: allowed.includes(parsed.verdict)
            ? parsed.verdict
            : "unverified",
          confidence: Math.min(
            100,
            Math.max(0, Number(parsed.confidence) || 0)
          ),
          reasoning: String(parsed.reasoning ?? ""),
          sources: Array.isArray(parsed.sources)
            ? parsed.sources.map(String)
            : []
        }
      });
    } catch {
      return NextResponse.json({
        result: {
          verdict: "unverified",
          confidence: 20,
          reasoning: text,
          sources: []
        }
      });
    }

  } catch (err: any) {
    return NextResponse.json({
      result: {
        verdict: "unverified",
        confidence: 0,
        reasoning: err?.message ?? "Unexpected server error.",
        sources: []
      }
    });
  }
}
